name: Update Submodules

on:
  repository_dispatch:
    types: [update-submodules]

concurrency:
  group: update-submodules-${{ github.event.client_payload.type }}-${{ github.event.client_payload.name }}
  cancel-in-progress: false

jobs:
  update:
    name: Update Project Submodule
    runs-on: ubuntu-latest
    outputs:
      repo: ${{ steps.submodule.outputs.repo }}
      name: ${{ steps.submodule.outputs.name }}

    steps:
      - name: 1Ô∏è‚É£ Checkout repo with submodules
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.CSK_PAT }}
          submodules: false

      - name: 2Ô∏è‚É£ Configure GitHub auth and identity
        shell: bash
        run: |
          git config --global url."https://${{ secrets.CSK_PAT }}@github.com/".insteadOf "https://github.com/"
          git config user.name "ianhub-bot"
          git config user.email "bot@ianhub.net"

      - name: 3Ô∏è‚É£ Add or Update Submodule
        id: submodule
        shell: bash
        run: |
          REPO="${{ github.event.client_payload.repo }}"
          NAME="${{ github.event.client_payload.name }}"
          if [ -z "$REPO" ] || [ -z "$NAME" ]; then
            echo "‚ùå Missing required payload fields."
            exit 1
          fi

          SUB_PATH="projects/$NAME"
          echo "üì¶ Name: $NAME"
          echo "üîó Repo: $REPO"
          echo "üìÇ Submodule path: $SUB_PATH"

          # Check if submodule exists
          if git config -f .gitmodules --get submodule."$SUB_PATH".url >/dev/null; then
            echo "üîç Submodule exists. Verifying repository URL..."

            # Normalize existing and expected URLs
            EXISTING_URL=$(git config -f .gitmodules --get submodule."$SUB_PATH".url | sed -E 's|https://.*@github.com/|https://github.com/|' | sed 's|\.git$||')
            EXPECTED_URL=$(echo "https://github.com/$REPO" | sed 's|\.git$||')

            if [ "$EXISTING_URL" != "$EXPECTED_URL" ]; then
              echo "‚ùå Repository mismatch detected!"
              exit 1
            fi

            echo "‚úÖ Repository verified. Updating..."
            git submodule update --init --remote "$SUB_PATH"
          else
            echo "‚ûï Submodule doesn't exist. Adding it..."
            mkdir -p "$(dirname "$SUB_PATH")"

            # Add using token for authentication, then normalize URL
            git submodule add "https://${{ secrets.CSK_PAT }}@github.com/$REPO" "$SUB_PATH"
            git config -f .gitmodules submodule."$SUB_PATH".url "https://github.com/$REPO"
            git submodule sync
          fi

          # Stage submodule changes
          git add .gitmodules "$SUB_PATH"

          # Pull latest main if nothing staged
          git fetch origin main --quiet
          if git diff --cached --quiet; then
            echo "üü¢ No staged changes. Safe to pull..."
            git merge --ff-only origin/main --quiet || true
          else
            echo "‚ö†Ô∏è Skipping merge to avoid overwriting staged submodule updates."
          fi

          # Commit if needed
          if git diff --cached --quiet; then
            echo "üü° No changes to commit."
          else
            echo "üìù Committing changes..."
            git commit -m "Auto-update/add submodule: ${NAME:-unknown}"
          fi

          # Push with retry
          echo "üöÄ Pushing to origin (with retry)..."
          for i in 1 2 3; do
            git push && break || {
              echo "‚ùå Push failed. Retry #$i in 3s..."
              sleep 3
            }
          done

          git status -sb

          echo "‚úÖ Done."
          echo "repo=$REPO" >> $GITHUB_OUTPUT
          echo "name=$NAME" >> $GITHUB_OUTPUT

  post-update:
    name: Upload Project Release to FTP
    needs: update
    runs-on: ubuntu-latest

    steps:
      - name: 1Ô∏è‚É£ Download latest release ZIP
        run: |
          REPO="${{ needs.update.outputs.repo }}"
          NAME="${{ needs.update.outputs.name }}"
          API_URL="https://api.github.com/repos/$REPO/releases/latest"

          echo "üîç Fetching latest release metadata..."
          curl -L -H "Authorization: token ${{ secrets.CSK_PAT }}" "$API_URL" > latest.json

          ZIP_URL=$(jq -r '.assets[] | select(.name | endswith(".zip")) | .browser_download_url' latest.json | head -n 1)
          VERSION=$(jq -r '.tag_name' latest.json)

          echo "üì¶ Version: $VERSION"
          echo "üì• ZIP URL: $ZIP_URL"

          if [ -z "$ZIP_URL" ] || [ "$ZIP_URL" == "null" ]; then
            echo "‚ùå No release asset found. Aborting."
            exit 1
          fi

          curl -L -o "${NAME}.zip" "$ZIP_URL"

          echo "ZIP=${NAME}.zip" >> $GITHUB_ENV
          echo "VERSION=$VERSION" >> $GITHUB_ENV

      - name: 2Ô∏è‚É£ Upload to FTP
        uses: SamKirkland/FTP-Deploy-Action@4.3.3
        with:
          server: ${{ secrets.FTP_HOST }}
          port: ${{ secrets.FTP_PORT }}
          username: ${{ secrets.FTP_USER }}
          password: ${{ secrets.FTP_PASS }}
          local-dir: ./
          server-dir: ${{ secrets.FTP_PATH }}
          state-name: ".sync-${{ needs.update.outputs.name }}-state.json"
          exclude: |
            **/*
            !${{ env.ZIP }}

      - name: 3Ô∏è‚É£ Send JSON-RPC
        shell: bash
        env:
          RPC_URL: ${{ secrets.RPC_URL }}
          RPC_KEY: ${{ secrets.RPC_KEY }}
          RPC_VER: ${{ secrets.RPC_VER }}
        run: |
          REPO="${{ needs.update.outputs.repo }}"
          REPO_URL="https://github.com/$REPO"
          TYPE="app"
          PACKAGE="${{ needs.update.outputs.name }}"
          OWNER="${REPO%%/*}"
          NAME="${REPO##*/}"
          ID=$(openssl rand -hex 8)

          curl -s -X POST "$RPC_URL" \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $RPC_KEY" \
            -d "{
              \"jsonrpc\": \"$RPC_VER\",
              \"method\": \"update\",
              \"params\": {
                \"type\": \"$TYPE\",
                \"package\": \"$PACKAGE\",
                \"repo\": \"$REPO_URL\",
                \"owner\": \"$OWNER\",
                \"name\": \"$NAME\",
                \"version\": \"${{ env.VERSION }}\"
              },
              \"id\": \"$ID\"
            }"
